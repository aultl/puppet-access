#!/usr/bin/perl -w
our $ID = q$Id: rebuild-access 2016-05-04 digant $;
#
# rebuild-access -- Construct an access.conf file from fragments.
#
# Written by Les Ault <les.ault@jtv.com> 
#
# Constructs an access.conf file from the prefix, standard, and suffix
# files in the access configuration area, adding any additional modules
# specified in the command line, and prints the resulting access.conf rules to
# standard output (suitable for saving into /etc/security/access.conf or some other
# appropriate location on the system).
    
##############################
## Modules and declarations ##
##############################
    
use strict;
 
use Getopt::Long qw(GetOptions);
    
# Path to the access template area.
our $TEMPLATE   = '/etc/security/access.d';
    
##################
## Installation ##
##################
    
# Return the prefix
sub prefix {
  my $data;
  ( $data = <<'END_OF_PREFIX' ) =~ s/^\s+//gm;
        ###############################################
        # Puppet Managed Configuration File           #
        # Do not edit this file manually as changes   #
        # will be overwritten by the PuppetMaster     #
        ###############################################
        
        # Users allowed to login
        +:root:ALL
        +:unixadmins:ALL

        # Allow users to run cronjobs (root/unixadmins will be allowed by default)
        +:root unixadmins: cron crond

        # Additional users that are permitted to login 
END_OF_PREFIX
    
  return $data;
}
    
# Return the suffix
sub suffix {
  my $data;
  ( $data = <<'END_OF_SUFFIX' ) =~ s/^\s+//gm;

        # Deny everyone else
        -:ALL:ALL
 
END_OF_SUFFIX
    
  return $data;
}

# Read in a file, processing includes as required.  Returns the contents of
# the file as an array.
sub read_access {
  my ($file) = @_;
  my @data;
  $file = $TEMPLATE . '/' . $file unless $file =~ m%^\.?/%;
  open my $MODULE, '<', $file or die "$0: cannot open $file: $!\n";
  local $_;
  while (<$MODULE>) {
    push (@data, $_);
  }
  close $MODULE;
  return @data;
}
    
# Write a file carefully.
# Consider using File::Temp
sub write_access {
  my ($file, @data) = @_;
  open my $NEW, '>', "$file.new" or die "$0: cannot create $file.new: $!\n";
  print $NEW @data            or die "$0: cannot write to $file.new: $!\n";
  close $NEW                  or die "$0: cannot flush $file.new: $!\n";

  # Make a backup file
  rename ('/etc/security/access.conf', '/etc/security/access.conf.1');
  
  # Write file         
  rename ("$file.new", $file) or die "$0: cannot install new $file: $!\n";
}
    
##################
## Main routine ##
##################
    
# Fix things up for error reporting.
$| = 1;
my $fullpath = $0;
$0 =~ s%.*/%%;
    
# Parse command-line options.
my ($help, $version);
Getopt::Long::config ('bundling', 'no_ignore_case');
GetOptions ('h|help'             => \$help,
            'v|version'          => \$version) or exit 1;
if ($help) {
  print "Feeding myself to perldoc, please wait....\n";
  exec ('perldoc', '-t', $fullpath);
} elsif ($version) {
  my $version = join (' ', (split (' ', $ID))[1..3]);
  $version =~ s/,v\b//;
  $version =~ s/(\S+)$/($1)/;
  $version =~ tr%/%-%;
  print $version, "\n";
  exit;
}
my @modules;
    
if ( -d '/etc/security/access.d' ) {
  @modules = </etc/security/access.d/*>;
}
    
# Concatenate everything together.
my @data;
push (@data, prefix());
push (@data, "\n");

for my $module (@modules) {
  push (@data, read_access($module));
  push (@data, "\n");
}
push (@data, suffix());

write_access ('/etc/security/access.conf', @data);    

exit 0;
__END__
    
###################
## Documentation ##
###################
    
=head1 NAME
  
rebuild-access - Construct an access.conf file from fragments
    
=head1 SYNOPSIS
    
rebuild-access [B<-hv>]
    
=head1 DESCRIPTION
    
B constructs an access configuration file by concatenating
various modules found in F.  The resulting access
configuration file is written to the appropriate file for Red Hat.
    
Each module is just a text file located in the directory mentioned above that
contains one or more iptables configuration lines (basically the arguments to
an B invocation), possibly including comments.
    
Along with the modules in the directory specified, a standard prefix and suffix
is added.
    
Normally, the contents of each module are read in verbatim, but a module may
also contain the directive:
    
 include 
    
on a separate line, where  is the path to another module to include,
specified the same way as modules given on the command line (hence, either a
file name relative to F or an
absolute path).  Such a line will be replaced with the contents of the named
file.  Be careful when using this directive to not create loops; files
including themselves will be detected, but more complex loops will not and
will result in infinite output.
    
=head1 OPTIONS
    
=over 4
    
=item B<-h>, B<--help>
    
Print out this documentation (which is done simply by feeding the script to
C).
    
=item B<-v>, B<--version>
    
Print out the version of B and exit.
    
=back
    
=head1 FILES
    
=over 4
    
=item F
    
The default module location.
    
=item F
    
If this file exists, the system is assumed to be a Debian system for
determining the installation location when B<-i> is used.
    
=item F
    
The install location of the generated configuration file on Debian.
    
=item F
    
If this file exists, the system is assumed to be a Red Hat system for
determining the installation location when B<-i> is used.
    
=item F
    
The install location of the generated configuration file on Red Hat.
    
=back
    
=head1 AUTHOR
    
Les Ault
    
=head1 SEE ALSO
    
pam(8)
    
=cut

